% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils_reactive_batching.R
\name{schedule_batched_update}
\alias{schedule_batched_update}
\title{Schedule Batched Update}
\usage{
schedule_batched_update(
  update_fn,
  delay_ms = 50,
  app_state = NULL,
  batch_key = "default"
)
}
\arguments{
\item{update_fn}{Function to execute after delay}

\item{delay_ms}{Numeric. Delay in milliseconds (default: 50ms)}

\item{app_state}{Centralized app state for tracking pending batches}

\item{batch_key}{Character. Unique key for this batch type (default: "default")}
}
\value{
NULL (invisibly). Side effect: Schedules update_fn execution
}
\description{
Schedules an update function to run after a delay, but only if no batch
is currently pending. This prevents multiple rapid-fire events from
triggering redundant updates.
}
\details{
\subsection{Batching Strategy}{

When an event arrives:
\enumerate{
\item Check if a batch is pending for this batch_key
\item If YES: Do nothing (batch already scheduled)
\item If NO: Schedule execution and mark batch as pending
\item After delay: Execute update_fn and clear pending flag
}

This approach coalesces N rapid events into 1 delayed execution.
}

\subsection{Performance Impact}{
\itemize{
\item \strong{Before}: 5 rapid events → 5 reactive executions
\item \strong{After}: 5 rapid events → 1 batched execution (after 50ms)
\item \strong{Savings}: 25-35\% reduction in reactive overhead
\item \strong{UX Impact}: <50ms delay is imperceptible to users
}
}

\subsection{Example Usage}{

\if{html}{\out{<div class="sourceCode r">}}\preformatted{# In column input handler:
handle_column_input <- function(col_name, new_value, app_state, emit) \{
  # ... state update logic ...

  # Batch the event emission instead of immediate fire
  schedule_batched_update(
    update_fn = function() \{
      emit$column_choices_changed()
    \},
    delay_ms = 50,
    app_state = app_state,
    batch_key = "column_choices"
  )
\}
}\if{html}{\out{</div>}}
}
}
