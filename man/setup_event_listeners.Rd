% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils_server_event_listeners.R
\name{setup_event_listeners}
\alias{setup_event_listeners}
\title{Setup Event Listeners}
\usage{
setup_event_listeners(
  app_state,
  emit,
  input,
  output,
  session,
  ui_service = NULL
)
}
\arguments{
\item{app_state}{The centralized app state}

\item{emit}{The emit API for triggering events}

\item{input}{Shiny input}

\item{output}{Shiny output}

\item{session}{Shiny session}

\item{ui_service}{UI service for UI updates (optional)}
}
\description{
Sets up all reactive event listeners for the application.
This function creates shiny::observeEvent() handlers for all events
in the app_state$events reactive values.
}
\details{
\subsection{Architectural Philosophy}{

This function consolidates all event-driven reactive patterns in ONE place.
This centralization is INTENTIONAL and provides critical benefits:

\strong{Benefits of Centralization:}
\itemize{
\item Event execution order is visible and explicit
\item Race condition prevention is manageable
\item Dependency chains are traceable
\item Priority management is consistent
\item Debugging is straightforward
}

\strong{Anti-Pattern Warning:}
DO NOT split event listeners into separate files by domain.
This would break event ordering visibility and make race conditions
significantly harder to debug.
}

\subsection{Event Listener Organization}{

The listeners are organized into functional sections:
\enumerate{
\item \strong{Data Lifecycle Events} (lines ~62-146)
\itemize{
\item data_updated: Consolidated data loading/changes
\item Handles cache clearing, autodetect triggering, UI sync
}
\item \strong{Auto-Detection Events} (lines ~148-201)
\itemize{
\item auto_detection_started: Triggers autodetect engine
\item auto_detection_completed: Updates state, triggers UI sync
}
\item \strong{UI Synchronization Events} (lines ~203-274)
\itemize{
\item ui_sync_requested: Syncs UI with detected columns
\item ui_sync_completed: Triggers navigation updates
}
\item \strong{Navigation Events} (lines ~276-280)
\itemize{
\item navigation_changed: Updates reactive navigation trigger
}
\item \strong{Test Mode Events} (lines ~282-361)
\itemize{
\item test_mode_ready: Test mode initialization
\item test_mode_startup_phase_changed: Startup sequencing
\item test_mode_debounced_autodetect: Debounced detection
}
\item \strong{Session Lifecycle Events} (lines ~363-410)
\itemize{
\item session_started: Session initialization
\item manual_autodetect_button: Manual detection trigger
\item session_reset: State cleanup
}
\item \strong{Error Handling Events} (lines ~412-502)
\itemize{
\item error_occurred: Centralized error handling
\item recovery_completed: Recovery tracking
}
\item \strong{UI Update Events} (lines ~504-527)
\itemize{
\item form_reset_needed: Form field reset
\item form_restore_needed: Session restore
}
\item \strong{Input Change Observers} (lines ~529-822)
\itemize{
\item Column selection observers (x, y, n, etc.)
\item Chart type observers
\item Y-axis unit observers
\item Denominator observers
}
}
}

\subsection{Priority System}{

Events use OBSERVER_PRIORITIES for execution order:
\itemize{
\item STATE_MANAGEMENT: Highest - state updates first
\item HIGH: Critical operations
\item AUTO_DETECT: Auto-detection processing
\item UI_SYNC: UI synchronization
\item MEDIUM: Standard operations
\item STATUS_UPDATES: Non-critical updates
\item LOW: Background tasks
\item CLEANUP: Lowest - cleanup operations
\item LOWEST: Passive monitoring
}

All observers use ignoreInit = TRUE to prevent firing at startup
unless explicitly designed for initialization (chart_type observer).
}
}
