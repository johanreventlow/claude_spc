% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils_server_column_input.R
\name{handle_column_input}
\alias{handle_column_input}
\title{Handle Column Input Change}
\usage{
handle_column_input(col_name, new_value, app_state, emit)
}
\arguments{
\item{col_name}{Character. Name of the column input (e.g., "x_column", "y_column")}

\item{new_value}{The new value from input[\link{col_name}]}

\item{app_state}{Centralized app state containing UI tokens and column mappings}

\item{emit}{Event emission API for triggering column_choices_changed event}
}
\value{
NULL (invisibly). Side effects: Updates app_state, emits events
}
\description{
Unified handler for column input changes. Processes user or programmatic
changes to column selection inputs with full token consumption, normalization,
state updates, and cache invalidation.
}
\details{
## Processing Flow

1. **Token Consumption**: Check if this is a programmatic update
   - If token exists and matches value, consume token and skip event emission
   - This prevents infinite loops from programmatic UI updates

2. **Normalization**: Convert input value to consistent string format
   - Handles NULL, empty vectors, empty strings
   - Returns normalized string or ""

3. **State Update**: Update app_state with normalized value
   - Updates app_state$columns[[col_name]]
   - Maintains synchronization between UI and state

4. **Cache Invalidation**: Clear cached column input if cache exists
   - Updates app_state$ui_cache[[cache_key]]
   - Ensures fresh data on next access

5. **Event Emission**: Emit column_choices_changed event for user changes
   - Only emits if NOT a programmatic update (token consumed)
   - Triggers downstream reactive updates
}
\examples{
\dontrun{
# In observer setup:
shiny::observeEvent(input$x_column, {
  handle_column_input("x_column", input$x_column, app_state, emit)
})
}

}
