% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils_server_column_input.R
\name{handle_column_input}
\alias{handle_column_input}
\title{Handle Column Input Change}
\usage{
handle_column_input(col_name, new_value, app_state, emit)
}
\arguments{
\item{col_name}{Character. Name of the column input (e.g., "x_column", "y_column")}

\item{new_value}{The new value from input[\link{col_name}]}

\item{app_state}{Centralized app state containing UI tokens and column mappings}

\item{emit}{Event emission API for triggering column_choices_changed event}
}
\value{
NULL (invisibly). Side effects: Updates app_state, emits events
}
\description{
Unified handler for column input changes. Processes user or programmatic
changes to column selection inputs with full token consumption, normalization,
state updates, and cache invalidation.
}
\details{
\subsection{Processing Flow}{
\enumerate{
\item \strong{Token Consumption}: Check if this is a programmatic update
\itemize{
\item If token exists and matches value, consume token and skip event emission
\item This prevents infinite loops from programmatic UI updates
}
\item \strong{Normalization}: Convert input value to consistent string format
\itemize{
\item Handles NULL, empty vectors, empty strings
\item Returns normalized string or ""
}
\item \strong{State Update}: Update app_state with normalized value
\itemize{
\item Updates app_state$columns[\link{col_name}]
\item Maintains synchronization between UI and state
}
\item \strong{Cache Invalidation}: Clear cached column input if cache exists
\itemize{
\item Updates app_state$ui_cache[\link{cache_key}]
\item Ensures fresh data on next access
}
\item \strong{Event Emission}: Emit column_choices_changed event for user changes
\itemize{
\item Only emits if NOT a programmatic update (token consumed)
\item Triggers downstream reactive updates
}
}
}
}
\examples{
\dontrun{
# In observer setup:
shiny::observeEvent(input$x_column, {
  handle_column_input("x_column", input$x_column, app_state, emit)
})
}

}
