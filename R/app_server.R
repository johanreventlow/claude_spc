# app_server.R  
# Main server function following Golem conventions

#' Main Server Function
#'
#' @param input,output,session Internal Shiny parameters
#' 
#' @noRd
app_server <- function(input, output, session) {
  # Initialize advanced debug system
  initialize_advanced_debug(enable_history = TRUE, max_history_entries = 1000)

  # Start session lifecycle debugging
  session_debugger <- debug_session_lifecycle(session$token, session)
  session_debugger$event("server_initialization")

  log_debug("===========================================", "APP_SERVER")
  log_debug("Starting main server function", "APP_SERVER")
  log_debug(paste("Session ID:", session$token), "APP_SERVER")

  debug_log("SPC App server initialization started", "SESSION_LIFECYCLE",
            level = "INFO", session_id = session$token)

  # Source all required server components
  log_debug("Sourcing server components...", "APP_SERVER")
  source("R/utils_reactive_state.R", local = TRUE)
  source("R/utils_session_helpers.R", local = TRUE)
  source("R/utils_server_management.R", local = TRUE)
  source("R/fct_data_processing.R", local = TRUE)
  source("R/fct_file_operations.R", local = TRUE)
  source("R/fct_visualization_server.R", local = TRUE)
  source("R/mod_spc_chart.R", local = TRUE)
  log_debug("‚úÖ All server components sourced", "APP_SERVER")

  # Reaktive V√¶rdier --------------------------------------------------------
  # Initialiser reaktive v√¶rdier
  log_debug("Initializing reactive values...", "APP_SERVER")
  debug_log("Creating reactive values", "SESSION_LIFECYCLE", level = "TRACE", session_id = session$token)
  values <- initialize_reactive_values()
  log_debug("‚úÖ Reactive values initialized", "APP_SERVER")
  session_debugger$event("reactive_values_initialized")

  # PHASE 4: Centraliseret state management (parallel til existing values)
  log_debug("Initializing centralized app state...", "APP_SERVER")
  debug_log("Creating centralized app_state", "SESSION_LIFECYCLE", level = "TRACE", session_id = session$token)
  app_state <- create_app_state()
  log_debug("‚úÖ Centralized state initialized", "APP_SERVER")
  session_debugger$event("centralized_state_initialized")

  # Take initial state snapshot
  initial_snapshot <- debug_state_snapshot("app_initialization", app_state, session_id = session$token)

  # FASE 5: Memory management setup
  log_debug("Setting up memory management...", "APP_SERVER")
  setup_session_cleanup(session, values, app_state)
  log_debug("‚úÖ Memory management configured", "APP_SERVER")

  # Test Tilstand ------------------------------------------------------------
  # TEST MODE: Auto-indl√¶s eksempel data hvis aktiveret
  log_debug("Checking TEST_MODE configuration...", "APP_SERVER")
  log_debug(paste("TEST_MODE_AUTO_LOAD:", if(exists("TEST_MODE_AUTO_LOAD")) TEST_MODE_AUTO_LOAD else "UNDEFINED"), "APP_SERVER")

  debug_log("Checking TEST_MODE configuration", "SESSION_LIFECYCLE", level = "TRACE",
            context = list(
              TEST_MODE_AUTO_LOAD = if(exists("TEST_MODE_AUTO_LOAD")) TEST_MODE_AUTO_LOAD else "UNDEFINED"
            ),
            session_id = session$token)

  if (exists("TEST_MODE_AUTO_LOAD") && TEST_MODE_AUTO_LOAD) {
    # Start workflow tracer for auto-load process
    autoload_tracer <- debug_workflow_tracer("test_mode_auto_load", app_state, session$token)
    log_debug(paste("üîÑ Attempting auto-load with TEST_MODE_AUTO_LOAD =", TEST_MODE_AUTO_LOAD), "TEST_MODE")
    test_file_path <- if(exists("TEST_MODE_FILE_PATH")) TEST_MODE_FILE_PATH else "UNDEFINED"
    log_debug(paste("Test file path:", test_file_path), "TEST_MODE")

    if (exists("TEST_MODE_FILE_PATH") && file.exists(test_file_path)) {
      log_debug("‚úÖ Test file found, starting auto-load...", "TEST_MODE")
      autoload_tracer$step("file_validation_complete")

      tryCatch(
        {
          autoload_tracer$step("data_loading_started")
          # Bestem hvilken loader der skal bruges baseret p√• fil-extension
          file_extension <- tools::file_ext(test_file_path)

          if (file_extension %in% c("xlsx", "xls")) {
            # Load Excel file
            test_data <- readxl::read_excel(
              test_file_path,
              sheet = 1, # L√¶s f√∏rste sheet
              .name_repair = "minimal"
            )
          } else {
            # Load CSV file using readr::read_csv2 (same as working file upload)
            test_data <- readr::read_csv2(
              test_file_path,
              locale = readr::locale(
                decimal_mark = ",",
                grouping_mark = ".",
                encoding = DEFAULT_ENCODING
              ),
              show_col_types = FALSE
            )
          }

          # Ensure standard columns are present
          test_data <- ensure_standard_columns(test_data)
          autoload_tracer$step("data_processing_complete")

          # Set reactive values - PHASE 4: Unified state only
          # Legacy values$current_data removed - now using app_state only
          # Legacy values$original_data removed - now using app_state only
          app_state$data$original_data <- test_data
          # Unified state: Set data and flags in both legacy and centralized state
          app_state$data$current_data <- test_data
          # PHASE 4B: Unified state assignment only
          app_state$session$file_uploaded <- TRUE
          # PHASE 4B: Unified state assignment only
          app_state$session$user_started_session <- TRUE
          # PHASE 4B: Unified state assignment only
          app_state$columns$auto_detect$completed <- FALSE
          # PHASE 4B: Legacy assignment removed - managed by unified state
          # PHASE 4B: Unified state assignment only
          app_state$ui$hide_anhoej_rules <- FALSE

          autoload_tracer$step("state_synchronization_complete")

          # Take state snapshot after auto-load
          debug_state_snapshot("after_test_data_autoload", app_state, session_id = session$token)

          # NOTE: Flag s√¶ttes efter setup_column_management() for at undg√• race condition

          # Debug output
          log_info(paste("Auto-indl√¶st fil:", test_file_path), "TEST_MODE")
          log_info(paste("Data dimensioner:", nrow(test_data), "x", ncol(test_data)), "TEST_MODE")
          log_info(paste("Kolonner:", paste(names(test_data), collapse = ", ")), "TEST_MODE")

          autoload_tracer$complete("test_data_autoload_complete")
        },
        error = function(e) {
          log_error(paste("Fejl ved indl√¶sning af", test_file_path, ":", e$message), "TEST_MODE")
        }
      )
    } else {
      log_warn(paste("Fil ikke fundet:", test_file_path), "TEST_MODE")
    }
  }

  # Observer Management ------------------------------------------------------
  # Initialiser observer manager til tracking af alle observers
  obs_manager <- observer_manager()

  # Waiter Konfiguration -----------------------------------------------------
  # Initialiser fil upload waiter
  waiter_file <- waiter::Waiter$new(
    html = WAITER_CONFIG$file_upload$html,
    color = WAITER_CONFIG$file_upload$color
  )

  # Server Setup ------------------------------------------------------------
  # Ops√¶t alle server-komponenter

  ## Velkomstside interaktioner
  setup_welcome_page_handlers(input, output, session, values, waiter_file, app_state)

  ## Session management logik
  setup_session_management(input, output, session, values, waiter_file, app_state)

  ## Fil upload logik
  setup_file_upload(input, output, session, values, waiter_file, app_state)

  ## Data tabel logik
  setup_data_table(input, output, session, values)

  ## Kolonne management logik
  # PHASE 4: Pass centralized state to column management
  setup_column_management(input, output, session, values, app_state)

  ## Visualiserings logik
  visualization <- setup_visualization(input, output, session, values, app_state)

  ## Download handlers
  setup_download_handlers(input, output, session, values)

  ## Hj√¶lpe observers
  setup_helper_observers(input, output, session, values, obs_manager, app_state)

  session_debugger$event("server_setup_complete")
  debug_log("All server components setup completed", "SESSION_LIFECYCLE", level = "INFO", session_id = session$token)

  # TEST MODE: Set auto-detect trigger flag AFTER all observers are set up
  if (TEST_MODE_AUTO_LOAD) {
    observe({
      # Unified state: Use centralized state as primary data source
      current_data_check <- app_state$data$current_data

      if (!is.null(current_data_check)) {
        log_debug("Setting test_mode_auto_detect_ready flag after setup", "TEST_MODE")
        timestamp <- Sys.time()

        # PHASE 4B: Unified state assignment only
        app_state$test_mode$auto_detect_ready <- timestamp
        log_debug("Synced test_mode_auto_detect_ready to both systems", "UNIFIED_STATE")
      }
    }) %>% bindEvent({
      # Unified state: Use centralized state for reactive triggers
      app_state$data$current_data
    }, once = TRUE, ignoreNULL = TRUE)
  }

  # Initial UI Setup --------------------------------------------------------
  # S√¶t standard chart_type n√•r appen starter
  observe({
    log_debug("Setting initial chart_type to 'run'", "APP_SERVER")
    updateSelectizeInput(session, "chart_type", selected = "run")
    log_debug("‚úÖ Initial chart_type set", "APP_SERVER")
  }) %>%
    bindEvent(TRUE, once = TRUE)

  # Session Cleanup ---------------------------------------------------------
  # Additional cleanup n√•r session lukker
  session$onSessionEnded(function() {
    session_debugger$event("session_cleanup_started")
    debug_log("Session cleanup initiated", "SESSION_LIFECYCLE", level = "INFO", session_id = session$token)

    # Cleanup alle observers
    obs_manager$cleanup_all()

    # Cleanup waiter
    if (exists("waiter_file") && !is.null(waiter_file)) {
      waiter_file$hide()
    }

    # Complete session lifecycle debugging
    session_lifecycle_result <- session_debugger$complete()

    # Log session statistics
    log_info(paste("Session afsluttet - Observer count:", obs_manager$count()), "APP_SERVER")
    debug_log("Session ended successfully", "SESSION_LIFECYCLE", level = "INFO",
              context = list(
                session_duration = round(session_lifecycle_result$total_duration, 3),
                events_tracked = length(session_lifecycle_result$events)
              ),
              session_id = session$token)
  })
}