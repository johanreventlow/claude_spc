# fct_spc_helpers.R
# SPC helper functions: date formatting, validation, preprocessing
# Extracted from fct_spc_calculations.R for better maintainability

# Dependencies ----------------------------------------------------------------
library(qicharts2)
library(ggplot2)
library(lubridate)

# HJÆLPEFUNKTIONER ============================================================

#' Konverter enheds-kode til dansk label
#'
#' @param unit_code Character. Kode for organisatorisk enhed
#' @param unit_list Named list. Mapping mellem enheder og koder
#' @return Character. Dansk label for enheden
#' @family spc_helpers
#' @export
get_unit_label <- function(unit_code, unit_list) {
  if (is.null(unit_code) || unit_code == "") {
    return("")
  }

  # Find dansk navn baseret på værdi
  unit_names <- names(unit_list)[unit_list == unit_code]
  if (length(unit_names) > 0) {
    return(unit_names[1])
  }

  # Fallback til koden selv
  return(unit_code)
}

#' Valider og formater X-akse data til SPC charts
#'
#' Intelligent validering og formatering af X-akse data, med automatisk
#' detektion af dato formater og optimeret visning baseret på data interval.
#'
#' @param x_data Vector. Rå X-akse data (datoer, tal eller tekst)
#' @return List med formateret data og metadata
#' @details
#' Validering proces:
#' \enumerate{
#'   \item Tjek om x_col eksisterer i data
#'   \item Forsøg dato parsing for forskellige formater
#'   \item Beregn optimal date interval hvis dato
#'   \item Generer formaterings string for qicharts2
#'   \item Fallback til numerisk sekvensnummerering
#' }
#'
#' Understøttede dato formater:
#' \itemize{
#'   \item "dd-mm-yyyy" (dansk standard)
#'   \item "yyyy-mm-dd" (ISO)
#'   \item "mm/dd/yyyy" (amerikansk)
#'   \item Automatisk locale detection
#' }
#'
#' @return List med formateret X-akse data:
#' \describe{
#'   \item{x_data}{Formateret X-akse værdier}
#'   \item{x.format}{qicharts2 formaterings string eller NULL}
#'   \item{is_date}{Logical - om data er datoer}
#'   \item{interval_info}{Liste med interval statistik (kun datoer)}
#' }
#'
#' @examples
#' \dontrun{
#' # Dato data
#' data <- data.frame(
#'   Dato = c("01-01-2024", "01-02-2024", "01-03-2024"),
#'   Værdi = c(95, 92, 98)
#' )
#' result <- validate_x_column_format(data, "Dato", "day")
#'
#' # Numerisk data
#' data_num <- data.frame(Obs = 1:10, Værdi = rnorm(10))
#' result <- validate_x_column_format(data_num, "Obs", "observation")
#' }
#'
#' @seealso \code{\link{detect_date_interval}}, \code{\link{get_optimal_formatting}}
validate_x_column_format <- function(data, x_col, x_axis_unit = "observation") {
  # Return default hvis ingen x-kolonne
  if (is.null(x_col) || !x_col %in% names(data)) {
    return(list(
      x_data = 1:nrow(data),
      x.format = NULL,
      is_date = FALSE
    ))
  }

  x_data <- data[[x_col]]

  # Tjek om data allerede er Date/POSIXct
  if (inherits(x_data, c("Date", "POSIXct", "POSIXt"))) {
    # Data er allerede formateret som dato/tid
    x_format <- get_x_format_string(x_axis_unit)
    return(list(
      x_data = x_data,
      x.format = x_format,
      is_date = TRUE
    ))
  }

  # Forsøg intelligent date detection med lubridate
  if (is.character(x_data) || is.factor(x_data)) {
    char_data <- as.character(x_data)[!is.na(x_data)]

    if (length(char_data) > 0) {
      # Test sample til date detection
      test_sample <- char_data[1:min(5, length(char_data))]

      # FØRST: Test danske dato-formater direkte (mest almindelige)
      danish_parsed <- suppressWarnings(lubridate::dmy(char_data))
      danish_success_rate <- sum(!is.na(danish_parsed)) / length(danish_parsed)

      if (danish_success_rate >= 0.7) {
        # Danske datoer fungerer - konverter til POSIXct for konsistens med qicharts2
        x_data_converted <- as.POSIXct(danish_parsed)
        x_format <- get_x_format_string(x_axis_unit)

        log_debug(paste("ON-THE-FLY: Konverterede", x_col, "danske datoer til POSIXct (success rate:", round(danish_success_rate, 2), ")"), "DATE_CONVERSION")

        return(list(
          x_data = x_data_converted,
          x.format = x_format,
          is_date = TRUE
        ))
      }

      # FALLBACK: Brug lubridate guess_formats for andre formater (med error handling)
      tryCatch(
        {
          guessed_formats <- suppressWarnings(
            lubridate::guess_formats(test_sample, c("ymd", "dmy", "mdy", "dby", "dmY", "Ymd", "mdY"))
          )

          if (!is.null(guessed_formats) && length(guessed_formats) > 0) {
            # Filtrer ugyldige formater (undgå "n" format problem)
            valid_formats <- guessed_formats[!grepl("^n$|Unknown", guessed_formats)]

            if (length(valid_formats) > 0) {
              # Test konvertering med guessed formats
              parsed_dates <- suppressWarnings(
                lubridate::parse_date_time(char_data, orders = valid_formats, quiet = TRUE)
              )

              if (!is.null(parsed_dates)) {
                success_rate <- sum(!is.na(parsed_dates)) / length(parsed_dates)

                if (success_rate >= 0.7) { # 70% success rate threshold
                  # Konverter til Date objekter
                  x_data_converted <- as.Date(parsed_dates)
                  x_format <- get_x_format_string(x_axis_unit)

                  return(list(
                    x_data = x_data_converted,
                    x.format = x_format,
                    is_date = TRUE
                  ))
                }
              }
            }
          }
        },
        error = function(e) {
          # Skip denne parsing metode hvis den fejler
          log_debug(paste("WARNING: guess_formats parsing fejlede:", e$message), "DATE_CONVERSION")
        }
      )
    }
  }

  # Numerisk data eller tekst der ikke kunne parses som datoer
  if (is.numeric(x_data)) {
    return(list(
      x_data = x_data,
      x.format = NULL,
      is_date = FALSE
    ))
  } else {
    # Fallback til observation nummer
    return(list(
      x_data = 1:length(x_data),
      x.format = NULL,
      is_date = FALSE
    ))
  }
}

## Simpel formatering baseret på x_axis_unit
get_x_format_string <- function(x_axis_unit) {
  switch(x_axis_unit,
    "date" = "%Y-%m-%d",
    "month" = "%b %Y",
    "year" = "%Y",
    "week" = "Uge %W",
    "hour" = "%H:%M",
    "%Y-%m-%d" # default
  )
}

## Intelligent dato-interval detektion
detect_date_interval <- function(dates, debug = TRUE) {
  if (length(dates) < 2) {
    return(list(type = "insufficient_data", consistency = 0, timespan_days = 0))
  }

  # Sorter datoer og beregn intervaller
  sorted_dates <- sort(dates[!is.na(dates)])
  if (length(sorted_dates) < 2) {
    return(list(type = "insufficient_data", consistency = 0, timespan_days = 0))
  }

  # Beregn forskelle mellem konsekutive datoer (i dage)
  intervals <- as.numeric(diff(sorted_dates))

  if (length(intervals) == 0) {
    return(list(type = "insufficient_data", consistency = 0, timespan_days = 0))
  }

  median_interval <- median(intervals, na.rm = TRUE)
  interval_variance <- var(intervals, na.rm = TRUE)
  consistency <- 1 - (sqrt(interval_variance) / median_interval) # Høj værdi = konsistent
  consistency <- max(0, min(1, consistency)) # Klamp til 0-1

  timespan_days <- as.numeric(max(sorted_dates) - min(sorted_dates))

  # Klassificer interval type baseret på median
  interval_type <- if (median_interval <= 1) {
    "daily"
  } else if (median_interval <= 10) {
    "weekly"
  } else if (median_interval <= 40) {
    "monthly"
  } else if (median_interval <= 120) {
    "quarterly"
  } else if (median_interval <= 400) {
    "yearly"
  } else {
    "irregular"
  }

  if (debug) {
    log_debug(paste("DATE INTERVAL DEBUG:\n- Observations:", length(sorted_dates), "\n- Median interval:", round(median_interval, 1), "days\n- Consistency:", round(consistency, 2), "\n- Type:", interval_type, "\n- Timespan:", round(timespan_days), "days"), "DATE_INTERVAL")
  }

  return(list(
    type = interval_type,
    median_days = median_interval,
    consistency = consistency,
    timespan_days = timespan_days,
    n_obs = length(sorted_dates)
  ))
}

## Optimal formatering baseret på interval og antal observationer
get_optimal_formatting <- function(interval_info, debug = TRUE) {
  interval_type <- interval_info$type
  n_obs <- interval_info$n_obs
  timespan_days <- interval_info$timespan_days

  # Formatering matrix baseret på interval type og antal observationer
  config <- switch(interval_type,
    daily = {
      if (n_obs < 30) {
        list(labels = "%d %b", breaks = "1 week", n_breaks = 8)
      } else if (n_obs < 90) {
        list(labels = "%b %Y", breaks = "2 weeks", n_breaks = 10)
      } else {
        list(labels = "%b %Y", breaks = "1 month", n_breaks = 12)
      }
    },
    weekly = {
      if (n_obs <= 36) {
        # Intelligent uge-formatering med scales::label_date_short()
        list(
          use_smart_labels = TRUE,
          labels = scales::label_date_short(),
          n_breaks = min(n_obs, 24) # Max 15 breaks for læsbarhed
        )
      } else {
        # For mange uger - skift til månedlig visning
        list(
          use_smart_labels = FALSE,
          labels = "%b %Y",
          breaks = "1 month",
          n_breaks = 12
        )
      }
    },
    monthly = {
      if (n_obs < 12) {
        # Intelligent måneds-formatering med scales::label_date_short()
        list(
          use_smart_labels = TRUE,
          labels = scales::label_date_short(
            format = c("%Y", "%b"), # År først, så måneder
            sep = "\n"
          ),
          breaks = "1 month",
          n_breaks = n_obs
        )
      } else if (n_obs < 40) {
        # Intelligent måneds-formatering med scales::label_date_short()
        list(
          use_smart_labels = TRUE,
          labels = scales::label_date_short(),
          breaks = "3 months",
          n_breaks = 8
        )
      } else {
        # For mange måneder - skift til årlig visning med smart labels
        list(
          use_smart_labels = TRUE,
          labels = scales::label_date_short(
            format = c("%Y", "", ""), # Kun år
            sep = ""
          ),
          breaks = "6 months",
          n_breaks = 10
        )
      }
    },
    quarterly = {
      list(labels = "Q%q %Y", breaks = "3 months", n_breaks = 8)
    },
    yearly = {
      list(labels = "%Y", breaks = "1 year", n_breaks = min(n_obs, 10))
    },
    # Default/irregular
    {
      # Tilpas til tidsspan
      if (timespan_days < 100) {
        list(labels = "%d %b %Y", breaks = "2 weeks", n_breaks = 8)
      } else if (timespan_days < 730) {
        list(labels = "%b %Y", breaks = "2 months", n_breaks = 10)
      } else {
        list(labels = "%Y", breaks = "1 year", n_breaks = 12)
      }
    }
  )

  if (debug) {
    log_debug(paste("FORMATTING DEBUG:\n- Selected labels:", if (is.function(config$labels)) "function (smart labels)" else config$labels, "\n- Selected breaks:", config$breaks, "\n- N breaks:", config$n_breaks, if (!is.null(config$use_smart_labels)) paste("\n- Smart labels:", config$use_smart_labels) else ""), "FORMATTING")
  }

  return(config)
}


# SPC PLOT GENERERING =========================================================

#' Process chart title for SPC plot
#'
#' @param chart_title_reactive Reactive function for chart title
#' @param config Chart configuration with y_col
#' @return Character string with processed title
process_chart_title <- function(chart_title_reactive, config) {
  log_debug("Processing chart title...", "SPC_CALC_DEBUG")

  custom_title <- tryCatch({
    if (!is.null(chart_title_reactive) && is.function(chart_title_reactive)) {
      log_debug("Calling chart_title_reactive function...", "SPC_CALC_DEBUG")
      title <- chart_title_reactive()
      log_debug(paste("chart_title_reactive returned:", if(is.null(title)) "NULL" else paste("'", title, "'", sep="")), "SPC_CALC_DEBUG")
      if (!is.null(title) && title != "" && title != "SPC Analyse") {
        log_debug("Using custom title", "SPC_CALC_DEBUG")
        title
      } else {
        log_debug("Using default title (custom title empty or default)", "SPC_CALC_DEBUG")
        NULL
      }
    } else {
      log_debug("No chart_title_reactive function provided", "SPC_CALC_DEBUG")
      NULL
    }
  }, error = function(e) {
    log_debug(paste("ERROR in chart_title_reactive:", e$message), "SPC_CALC_DEBUG")
    NULL
  })

  log_debug(paste("Final custom_title result:", if(is.null(custom_title)) "NULL" else paste("'", custom_title, "'", sep="")), "SPC_CALC_DEBUG")

  if (!is.null(custom_title)) {
    custom_title
  } else {
    paste("SPC Chart -", config$y_col)
  }
}

#' Validate input parameters for SPC plot generation
#'
#' @param data Input data frame
#' @param config Chart configuration
validate_spc_inputs <- function(data, config) {
  if (is.null(data) || !is.data.frame(data) || nrow(data) == 0) {
    stop("Ingen gyldig data at visualisere")
  }

  if (is.null(config$y_col) || !config$y_col %in% names(data)) {
    stop("Y-kolonne ikke fundet i data")
  }
}

#' Process phase and freeze configuration
#'
#' @param data Input data frame
#' @param show_phases Logical indicating if phases should be shown
#' @param skift_column Column name for phase shifts
#' @param frys_column Column name for baseline freeze
#' @return List with part_positions and freeze_position
process_phase_freeze_config <- function(data, show_phases, skift_column, frys_column) {
  log_debug("Processing skift_column for phases...", "SPC_CALC_DEBUG")
  log_debug(paste("show_phases:", show_phases), "SPC_CALC_DEBUG")
  log_debug(paste("skift_column value:", if(is.null(skift_column)) "NULL" else paste("'", skift_column, "' (length:", length(skift_column), ")", sep="")), "SPC_CALC_DEBUG")

  part_positions <- NULL
  if (show_phases && !is.null(skift_column)) {
    log_debug("Checking if skift_column exists in data...", "SPC_CALC_DEBUG")
    # DEFENSIVE: Check for character(0) before using %in%
    if (length(skift_column) == 0 || identical(skift_column, character(0))) {
      log_debug("⚠️ skift_column is character(0) - skipping phase processing", "SPC_CALC_DEBUG")
    } else if (skift_column %in% names(data)) {
      log_debug(paste("✓ skift_column", skift_column, "found in data"), "SPC_CALC_DEBUG")
      skift_data <- data[[skift_column]]

      # Convert to logical if needed
      if (!is.logical(skift_data)) {
        skift_data <- as.logical(skift_data)
      }

      # Get positions where TRUE values occur (these are where new phases start)
      skift_points <- which(skift_data == TRUE)
      log_debug(paste("Skift points found:", length(skift_points), "positions:", paste(skift_points, collapse=", ")), "SPC_CALC_DEBUG")

      if (length(skift_points) > 0) {
        # qic() expects integer vector of positions where new phases start
        part_positions <- sort(skift_points)
        log_debug(paste("Final part_positions:", paste(part_positions, collapse=", ")), "SPC_CALC_DEBUG")
      }
    } else {
      log_debug(paste("⚠️ skift_column", skift_column, "not found in data columns:", paste(names(data), collapse=", ")), "SPC_CALC_DEBUG")
    }
  } else {
    log_debug("Skipping phase processing (show_phases=FALSE or skift_column=NULL)", "SPC_CALC_DEBUG")
  }

  # Handle baseline freeze from selected Frys column
  log_debug("Processing frys_column for baseline freeze...", "SPC_CALC_DEBUG")
  log_debug(paste("frys_column value:", if(is.null(frys_column)) "NULL" else paste("'", frys_column, "' (length:", length(frys_column), ")", sep="")), "SPC_CALC_DEBUG")

  freeze_position <- NULL
  if (!is.null(frys_column)) {
    log_debug("Checking if frys_column exists in data...", "SPC_CALC_DEBUG")
    # DEFENSIVE: Check for character(0) before using %in%
    if (length(frys_column) == 0 || identical(frys_column, character(0))) {
      log_debug("⚠️ frys_column is character(0) - skipping freeze processing", "SPC_CALC_DEBUG")
    } else if (frys_column %in% names(data)) {
      log_debug(paste("✓ frys_column", frys_column, "found in data"), "SPC_CALC_DEBUG")
      frys_data <- data[[frys_column]]

      # Convert to logical if needed
      if (!is.logical(frys_data)) {
        frys_data <- as.logical(frys_data)
      }

      # Get positions where TRUE values occur (baseline freeze points)
      frys_points <- which(frys_data == TRUE)
      log_debug(paste("Frys points found:", length(frys_points), "positions:", paste(frys_points, collapse=", ")), "SPC_CALC_DEBUG")

      if (length(frys_points) > 0) {
        # Use the last TRUE position as freeze point (baseline up to this point)
        freeze_position <- max(frys_points)
        log_debug(paste("Final freeze_position:", freeze_position), "SPC_CALC_DEBUG")
      }
    } else {
      log_debug(paste("⚠️ frys_column", frys_column, "not found in data columns:", paste(names(data), collapse=", ")), "SPC_CALC_DEBUG")
    }
  } else {
    log_debug("Skipping freeze processing (frys_column=NULL)", "SPC_CALC_DEBUG")
  }

  log_debug(paste("Final part_positions result:", if(is.null(part_positions)) "NULL" else paste(part_positions, collapse=", ")), "SPC_CALC_DEBUG")
  log_debug(paste("Final freeze_position result:", if(is.null(freeze_position)) "NULL" else freeze_position), "SPC_CALC_DEBUG")

  list(
    part_positions = part_positions,
    freeze_position = freeze_position
  )
}

## Generér SPC plot med tilpasset styling
